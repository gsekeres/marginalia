<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marginalia - Literature Management</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&family=Source+Serif+4:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">

    <!-- Tailwind (for utilities only) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <!-- Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>

    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- vis.js for network graph -->
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>

    <style>
        /* Design Tokens */
        :root {
            /* Paper & Ink palette */
            --bg: #FBF7EF;
            --surface: #F4EEE3;
            --surface-hover: #EDE5D6;
            --border: #E6DDCF;
            --border-strong: #D4C9B8;

            /* Text hierarchy */
            --text: #1F2328;
            --text-muted: #57606A;
            --text-subtle: #8B949E;

            /* Accent colors */
            --accent: #22324A;
            --accent-hover: #2D4263;
            --accent-muted: #8B3A3A;

            /* Status colors (muted, scholarly) */
            --status-discovered: #8B949E;
            --status-wanted: #3B5998;
            --status-queued: #B08D57;
            --status-downloaded: #2D6A4F;
            --status-summarized: #5B4B8A;
            --status-failed: #9B2C2C;

            /* Spacing scale */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-6: 24px;
            --space-8: 32px;

            /* Typography */
            --font-ui: 'Inter', -apple-system, sans-serif;
            --font-reading: 'Source Serif 4', Georgia, serif;
            --font-mono: 'JetBrains Mono', 'IBM Plex Mono', monospace;
        }

        [x-cloak] { display: none !important; }

        /* Base styles */
        body {
            font-family: var(--font-ui);
            background: var(--bg);
            color: var(--text);
        }

        /* Typography classes */
        .font-ui { font-family: var(--font-ui); }
        .font-reading { font-family: var(--font-reading); }
        .font-mono { font-family: var(--font-mono); }

        .h1 {
            font-family: var(--font-reading);
            font-size: 1.75rem;
            font-weight: 600;
            line-height: 1.3;
            color: var(--text);
        }
        .h2 {
            font-family: var(--font-ui);
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
        }
        .h3 {
            font-family: var(--font-ui);
            font-size: 1rem;
            font-weight: 600;
            color: var(--text);
        }

        /* Layout */
        .app-shell {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 220px;
            background: var(--surface);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            z-index: 10;
        }

        .sidebar-header {
            padding: var(--space-6);
            border-bottom: 1px solid var(--border);
        }

        .logo {
            font-family: var(--font-reading);
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text);
        }

        .sidebar-nav {
            padding: var(--space-4);
            flex: 1;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            border-radius: 6px;
            color: var(--text-muted);
            text-decoration: none;
            font-size: 0.9375rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-bottom: var(--space-1);
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .nav-item:hover {
            background: var(--surface-hover);
            color: var(--text);
        }

        .nav-item.active {
            background: var(--bg);
            color: var(--text);
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        .nav-icon {
            width: 18px;
            height: 18px;
            color: inherit;
            flex-shrink: 0;
        }

        .nav-count {
            margin-left: auto;
            font-size: 0.75rem;
            background: var(--bg);
            padding: 2px 8px;
            border-radius: 10px;
            color: var(--text-muted);
        }

        .sidebar-section {
            padding: var(--space-4);
            border-top: 1px solid var(--border);
        }

        .sidebar-footer {
            padding: var(--space-4);
            border-top: 1px solid var(--border);
        }

        /* Main area */
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            margin-left: 220px; /* Account for fixed sidebar */
        }

        /* Topbar */
        .topbar {
            display: flex;
            align-items: center;
            padding: var(--space-4) var(--space-6);
            background: var(--bg);
            border-bottom: 1px solid var(--border);
            gap: var(--space-4);
        }

        .topbar-left {
            min-width: 120px;
        }

        .topbar-center {
            flex: 1;
            max-width: 480px;
        }

        .topbar-right {
            display: flex;
            gap: var(--space-3);
            align-items: center;
        }

        .search-box {
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: var(--space-2) var(--space-4);
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--surface);
            font-size: 0.9375rem;
            color: var(--text);
            transition: all 0.15s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent);
            background: #fff;
            box-shadow: 0 0 0 3px rgba(34, 50, 74, 0.1);
        }

        .search-input::placeholder {
            color: var(--text-subtle);
        }

        /* Content area */
        .content {
            flex: 1;
            padding: var(--space-6);
            overflow-y: auto;
        }

        /* Buttons */
        .btn-primary {
            background: var(--accent);
            color: #fff;
            padding: var(--space-2) var(--space-4);
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text);
            padding: var(--space-2) var(--space-4);
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .btn-secondary:hover {
            background: var(--surface-hover);
            border-color: var(--border-strong);
        }

        .btn-icon {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-muted);
            transition: all 0.15s ease;
        }

        .btn-icon:hover {
            background: var(--surface-hover);
            color: var(--text);
        }

        .btn-text {
            background: none;
            border: none;
            color: var(--accent);
            padding: var(--space-1) var(--space-2);
            font-size: 0.875rem;
            cursor: pointer;
            text-decoration: none;
        }

        .btn-text:hover {
            text-decoration: underline;
        }

        .link-btn {
            background: none;
            border: none;
            color: var(--accent);
            font-size: 0.875rem;
            cursor: pointer;
            padding: 0;
        }

        .link-btn:hover {
            text-decoration: underline;
        }

        /* Status badges */
        .status-badge {
            font-family: var(--font-ui);
            font-size: 0.6875rem;
            font-weight: 500;
            padding: 3px 10px;
            border-radius: 3px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            display: inline-block;
        }

        .status-badge.discovered { background: #F0EDE8; color: var(--status-discovered); border: 1px solid #E0DBD3; }
        .status-badge.downloaded { background: #E8F4EE; color: var(--status-downloaded); border: 1px solid #C8E4D8; }
        .status-badge.summarized { background: #F0EBF8; color: var(--status-summarized); border: 1px solid #DCD4EC; }

        /* Status dot */
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }

        .status-dot.discovered { background: var(--status-discovered); }
        .status-dot.downloaded { background: var(--status-downloaded); }
        .status-dot.summarized { background: var(--status-summarized); }

        /* Cards */
        .card {
            background: #fff;
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
        }

        .stat-card {
            padding: var(--space-4);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .stat-card:hover {
            border-color: var(--border-strong);
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .stat-card.active {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(34, 50, 74, 0.1);
        }

        .stat-value {
            font-family: var(--font-reading);
            font-size: 1.75rem;
            font-weight: 600;
            color: var(--text);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: capitalize;
        }

        /* Papers table */
        .papers-table {
            width: 100%;
            border-collapse: collapse;
        }

        .papers-table th {
            text-align: left;
            padding: var(--space-3) var(--space-4);
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .papers-table td {
            padding: var(--space-3) var(--space-4);
            border-bottom: 1px solid var(--border);
            vertical-align: top;
        }

        .paper-row {
            cursor: pointer;
            transition: background 0.1s ease;
        }

        .paper-row:hover {
            background: var(--surface);
        }

        .paper-row:hover .paper-row-actions {
            opacity: 1;
        }

        .paper-title {
            font-family: var(--font-reading);
            font-size: 0.9375rem;
            font-weight: 500;
            color: var(--text);
            line-height: 1.4;
        }

        .paper-authors {
            font-size: 0.8125rem;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .paper-citekey {
            font-family: var(--font-mono);
            font-size: 0.6875rem;
            color: var(--text-subtle);
            margin-top: 2px;
        }

        .paper-row-actions {
            opacity: 0;
            transition: opacity 0.15s ease;
            display: flex;
            gap: var(--space-2);
        }

        .paper-row-actions button {
            background: none;
            border: none;
            cursor: pointer;
            padding: var(--space-1);
            color: var(--text-muted);
            border-radius: 4px;
        }

        .paper-row-actions button:hover {
            background: var(--surface-hover);
            color: var(--text);
        }

        /* Paper detail view */
        .paper-detail {
            position: fixed;
            inset: 0;
            background: var(--bg);
            z-index: 50;
            display: flex;
            flex-direction: column;
        }

        .paper-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-4) var(--space-6);
            border-bottom: 1px solid var(--border);
            background: #fff;
        }

        .paper-detail-actions {
            display: flex;
            gap: var(--space-3);
            align-items: center;
        }

        .paper-detail-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .paper-margin {
            width: 200px;
            padding: var(--space-6);
            background: var(--surface);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            flex-shrink: 0;
        }

        .margin-section {
            margin-bottom: var(--space-6);
        }

        .margin-label {
            display: block;
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: var(--space-1);
        }

        .margin-value {
            font-size: 0.875rem;
            color: var(--text);
        }

        .margin-link {
            font-size: 0.8125rem;
            color: var(--accent);
            text-decoration: none;
            word-break: break-all;
        }

        .margin-link:hover {
            text-decoration: underline;
        }

        .paper-main {
            flex: 1;
            padding: var(--space-8);
            overflow-y: auto;
            max-width: 800px;
        }

        .paper-authors-full {
            font-size: 1rem;
            color: var(--text-muted);
            margin-top: var(--space-2);
            margin-bottom: var(--space-6);
        }

        .paper-section {
            margin-bottom: var(--space-8);
        }

        .paper-section .h2 {
            margin-bottom: var(--space-3);
        }

        .body-reading {
            font-family: var(--font-reading);
            font-size: 1rem;
            line-height: 1.7;
            color: var(--text);
        }

        /* Markdown content styles */
        .markdown-body h1, .markdown-body h2, .markdown-body h3 {
            font-family: var(--font-ui);
            font-weight: 600;
            margin-top: var(--space-6);
            margin-bottom: var(--space-3);
            color: var(--text);
        }
        .markdown-body h2 { font-size: 1.125rem; }
        .markdown-body h3 { font-size: 1rem; }
        .markdown-body p { margin-bottom: var(--space-4); }
        .markdown-body ul, .markdown-body ol {
            margin-bottom: var(--space-4);
            padding-left: var(--space-6);
        }
        .markdown-body li { margin-bottom: var(--space-2); }
        .markdown-body strong { font-weight: 600; }
        .markdown-body em { font-style: italic; }
        .markdown-body code {
            font-family: var(--font-mono);
            font-size: 0.875em;
            background: var(--surface);
            padding: 2px 6px;
            border-radius: 3px;
        }
        .markdown-body pre {
            background: var(--surface);
            padding: var(--space-4);
            border-radius: 6px;
            overflow-x: auto;
            margin-bottom: var(--space-4);
        }
        .markdown-body pre code {
            background: none;
            padding: 0;
        }
        .markdown-body blockquote {
            border-left: 3px solid var(--border-strong);
            padding-left: var(--space-4);
            color: var(--text-muted);
            font-style: italic;
            margin-bottom: var(--space-4);
        }
        .markdown-body hr {
            border: none;
            border-top: 1px solid var(--border);
            margin: var(--space-6) 0;
        }

        /* Citation block */
        .citation-block {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: var(--space-4);
            margin-bottom: var(--space-6);
        }

        .citation-block-header {
            font-family: var(--font-ui);
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: var(--space-2);
        }

        .citation-block pre {
            font-family: var(--font-mono);
            font-size: 0.8125rem;
            line-height: 1.5;
            margin: 0;
            white-space: pre;
            overflow-x: auto;
        }

        /* Related papers */
        .related-paper-card {
            padding: var(--space-4);
            border: 1px solid var(--border);
            border-radius: 6px;
            margin-bottom: var(--space-3);
            background: #fff;
        }

        .related-paper-title {
            font-family: var(--font-reading);
            font-weight: 500;
            color: var(--text);
        }

        .related-paper-meta {
            font-size: 0.8125rem;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .related-paper-reason {
            font-size: 0.875rem;
            font-style: italic;
            color: var(--text-muted);
            margin-top: var(--space-2);
        }

        .related-paper-actions {
            margin-top: var(--space-3);
        }

        /* Queue view */
        .queue-card {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: var(--space-4);
            border: 1px solid var(--border);
            border-radius: 6px;
            background: #fff;
            margin-bottom: var(--space-3);
        }

        .queue-card-main {
            flex: 1;
        }

        .queue-card-actions {
            display: flex;
            gap: var(--space-2);
            flex-shrink: 0;
        }

        /* Alerts */
        .alert {
            padding: var(--space-4);
            border-radius: 6px;
            margin-bottom: var(--space-4);
        }

        .alert-success {
            background: #E8F4EE;
            border: 1px solid #C8E4D8;
            color: var(--status-downloaded);
        }

        .alert-error {
            background: #FAEBEB;
            border: 1px solid #F0D4D4;
            color: var(--status-failed);
        }

        .alert-info {
            background: #EBF0F8;
            border: 1px solid #D4DEF0;
            color: var(--status-wanted);
        }

        .alert-warning {
            background: #F8F3E8;
            border: 1px solid #E8DFC8;
            color: var(--status-queued);
        }

        /* Job progress */
        .job-progress {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-2) 0;
        }

        .job-progress-bar {
            flex: 1;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
        }

        .job-progress-fill {
            height: 100%;
            background: var(--status-queued);
            transition: width 0.3s ease;
        }

        /* Modal overlay */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            padding: var(--space-6);
        }

        .modal {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow: hidden;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-4) var(--space-6);
            border-bottom: 1px solid var(--border);
        }

        .modal-body {
            padding: var(--space-6);
            overflow-y: auto;
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-4);
            background: var(--surface);
            border-top: 1px solid var(--border);
        }

        .pagination-info {
            font-size: 0.8125rem;
            color: var(--text-muted);
        }

        .pagination-buttons {
            display: flex;
            gap: var(--space-2);
        }

        /* Actions bar */
        .actions-bar {
            display: flex;
            gap: var(--space-3);
            align-items: center;
            padding: var(--space-3) var(--space-4);
            background: var(--surface);
            border-radius: 6px;
            margin-bottom: var(--space-4);
        }

        .actions-bar-divider {
            width: 1px;
            height: 24px;
            background: var(--border);
        }

        /* Checkbox styling */
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* View header */
        .view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-4);
        }

        /* Manual queue link */
        .search-link {
            font-size: 0.75rem;
            padding: var(--space-1) var(--space-2);
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-muted);
            text-decoration: none;
        }

        .search-link:hover {
            background: var(--surface-hover);
            color: var(--text);
        }

        /* Browse modal */
        .browse-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 6px;
            margin-bottom: var(--space-4);
        }

        .browse-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            font-size: 0.875rem;
        }

        .browse-item:last-child {
            border-bottom: none;
        }

        .browse-item:hover {
            background: var(--surface);
        }

        .browse-item.parent {
            color: var(--text-muted);
            font-style: italic;
        }

        .browse-item .icon {
            width: 16px;
            text-align: center;
            color: var(--text-muted);
        }

        .browse-current {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            padding: var(--space-2) var(--space-3);
            background: var(--surface);
            border-radius: 4px;
            margin-bottom: var(--space-3);
            word-break: break-all;
        }

        /* Inline input with browse button */
        .input-with-browse {
            display: flex;
            gap: var(--space-2);
        }

        .input-with-browse input {
            flex: 1;
        }

        .btn-browse {
            padding: var(--space-2) var(--space-3);
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            white-space: nowrap;
        }

        .btn-browse:hover {
            background: var(--surface-hover);
        }

        /* User info in sidebar */
        .user-info-sidebar {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-3) var(--space-4);
            border-top: 1px solid var(--border);
            margin-top: var(--space-2);
        }

        .user-avatar-small {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .user-name-small {
            font-size: 0.8125rem;
            color: var(--text-muted);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* View toggle buttons */
        .view-toggle {
            display: flex;
            background: var(--surface);
            border-radius: 6px;
            padding: 2px;
        }

        .view-toggle button {
            padding: 6px 12px;
            border: none;
            background: none;
            border-radius: 4px;
            font-size: 0.8125rem;
            font-weight: 500;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .view-toggle button.active {
            background: white;
            color: var(--text);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .view-toggle button:hover:not(.active) {
            color: var(--text);
        }

        /* PDF Viewer */
        .pdf-viewer-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #525659;
            overflow: hidden;
        }

        .pdf-toolbar {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-2) var(--space-4);
            background: #3D4043;
            color: white;
        }

        .pdf-toolbar button {
            padding: 6px 12px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 0.8125rem;
        }

        .pdf-toolbar button:hover {
            background: rgba(255,255,255,0.2);
        }

        .pdf-toolbar button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pdf-page-info {
            font-size: 0.8125rem;
            color: rgba(255,255,255,0.8);
        }

        .highlight-colors {
            display: flex;
            gap: 4px;
            margin-left: auto;
        }

        .highlight-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.1s ease;
        }

        .highlight-color:hover {
            transform: scale(1.1);
        }

        .highlight-color.active {
            border-color: white;
        }

        .highlight-color.yellow { background: rgba(255, 235, 59, 0.7); }
        .highlight-color.green { background: rgba(76, 175, 80, 0.7); }
        .highlight-color.blue { background: rgba(33, 150, 243, 0.7); }
        .highlight-color.pink { background: rgba(233, 30, 99, 0.7); }

        .pdf-canvas-container {
            flex: 1;
            overflow: auto;
            display: flex;
            justify-content: center;
            padding: var(--space-4);
        }

        .pdf-page-wrapper {
            position: relative;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .pdf-canvas {
            display: block;
        }

        .pdf-text-layer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            pointer-events: all;
        }

        .pdf-text-layer span {
            position: absolute;
            white-space: pre;
            color: transparent;
            pointer-events: all;
            cursor: text;
        }

        .pdf-text-layer ::selection {
            background: rgba(255, 235, 59, 0.4);
        }

        .pdf-highlight-layer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .pdf-highlight {
            position: absolute;
            pointer-events: auto;
            cursor: pointer;
            transition: opacity 0.15s ease;
        }

        .pdf-highlight:hover {
            opacity: 0.8;
        }

        .pdf-highlight.yellow { background: rgba(255, 235, 59, 0.4); }
        .pdf-highlight.green { background: rgba(76, 175, 80, 0.4); }
        .pdf-highlight.blue { background: rgba(33, 150, 243, 0.4); }
        .pdf-highlight.pink { background: rgba(233, 30, 99, 0.4); }

        /* Notes Panel */
        .notes-panel {
            width: 350px;
            background: white;
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .notes-panel-header {
            padding: var(--space-3) var(--space-4);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .notes-panel-header h3 {
            font-size: 0.875rem;
            font-weight: 600;
        }

        .notes-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
        }

        .notes-tab {
            flex: 1;
            padding: var(--space-2) var(--space-3);
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            font-size: 0.8125rem;
            font-weight: 500;
            color: var(--text-muted);
            cursor: pointer;
        }

        .notes-tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .notes-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-4);
        }

        .notes-textarea {
            width: 100%;
            min-height: 200px;
            padding: var(--space-3);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: var(--font-mono);
            font-size: 0.8125rem;
            resize: vertical;
            margin-bottom: var(--space-3);
        }

        .notes-textarea:focus {
            outline: none;
            border-color: var(--accent);
        }

        .notes-preview {
            padding: var(--space-3);
            background: var(--surface);
            border-radius: 6px;
            font-family: var(--font-reading);
            font-size: 0.9375rem;
            line-height: 1.6;
        }

        .highlights-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
        }

        .highlight-item {
            padding: var(--space-3);
            background: var(--surface);
            border-radius: 6px;
            border-left: 3px solid;
            position: relative;
        }

        .highlight-item.yellow { border-left-color: #FFEB3B; }
        .highlight-item.green { border-left-color: #4CAF50; }
        .highlight-item.blue { border-left-color: #2196F3; }
        .highlight-item.pink { border-left-color: #E91E63; }

        .highlight-item-text {
            font-size: 0.875rem;
            line-height: 1.5;
            margin-bottom: var(--space-2);
        }

        .highlight-item-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .highlight-item-delete {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .highlight-item-delete:hover {
            background: var(--surface-hover);
            color: var(--status-failed);
        }

        /* Network Graph */
        .graph-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg);
        }

        .graph-toolbar {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .graph-toolbar input {
            flex: 1;
            max-width: 300px;
            padding: var(--space-2) var(--space-3);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.875rem;
        }

        .graph-toolbar input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .graph-canvas {
            flex: 1;
            min-height: 500px;
        }

        .graph-connection-panel {
            padding: var(--space-4);
            background: white;
            border-top: 1px solid var(--border);
        }

        .graph-connection-panel h4 {
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: var(--space-3);
        }

        .connection-form {
            display: flex;
            gap: var(--space-2);
            align-items: flex-end;
        }

        .connection-form .form-group {
            flex: 1;
        }

        .connection-form label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: var(--space-1);
        }

        .connection-form input {
            width: 100%;
            padding: var(--space-2);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 0.8125rem;
        }
    </style>
</head>
<body x-data="app()" x-init="init()">
    <div class="app-shell">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <h1 class="logo">Marginalia</h1>
            </div>

            <nav class="sidebar-nav">
                <button class="nav-item" :class="{ active: currentView === 'library' }" @click="currentView = 'library'">
                    <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <path d="M12 6.042A8.967 8.967 0 006 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 016 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 016-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0018 18a8.967 8.967 0 00-6 2.292m0-14.25v14.25"/>
                    </svg>
                    <span>Library</span>
                    <span class="nav-count" x-text="stats.total || 0"></span>
                </button>
                <button class="nav-item" :class="{ active: currentView === 'network' }" @click="switchToNetworkView()">
                    <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <circle cx="12" cy="12" r="3"/>
                        <circle cx="5" cy="6" r="2"/>
                        <circle cx="19" cy="6" r="2"/>
                        <circle cx="5" cy="18" r="2"/>
                        <circle cx="19" cy="18" r="2"/>
                        <path d="M7 6.5l2.5 4M17 6.5l-2.5 4M7 17.5l2.5-4M17 17.5l-2.5-4"/>
                    </svg>
                    <span>Network</span>
                </button>
            </nav>

            <div class="sidebar-section">
                <h2 class="h2" style="margin-bottom: var(--space-3);">Stats</h2>
                <div style="font-size: 0.8125rem; color: var(--text-muted);">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                        <span>Discovered</span>
                        <span x-text="stats.by_status?.discovered || 0"></span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                        <span>Downloaded</span>
                        <span x-text="stats.by_status?.downloaded || 0"></span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                        <span>Summarized</span>
                        <span x-text="stats.by_status?.summarized || 0"></span>
                    </div>
                </div>
            </div>

            <div class="sidebar-footer">
                <button class="nav-item" @click="importMessage = null; showImportModal = true">
                    <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <path d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m6.75 12l-3-3m0 0l-3 3m3-3v6m-1.5-15H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z"/>
                    </svg>
                    <span>Import</span>
                </button>
                <button class="nav-item" @click="syncResult = null; showSyncModal = true">
                    <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <path d="M7.5 7.5h-.75A2.25 2.25 0 004.5 9.75v7.5a2.25 2.25 0 002.25 2.25h7.5a2.25 2.25 0 002.25-2.25v-7.5a2.25 2.25 0 00-2.25-2.25h-.75m-6 3.75l3 3m0 0l3-3m-3 3V1.5m6 9h.75a2.25 2.25 0 012.25 2.25v7.5a2.25 2.25 0 01-2.25 2.25h-7.5a2.25 2.25 0 01-2.25-2.25v-.75"/>
                    </svg>
                    <span>Sync</span>
                </button>

                <!-- User info (if authenticated) -->
                <template x-if="currentUser">
                    <div class="user-info-sidebar">
                        <img :src="currentUser.picture" class="user-avatar-small" x-show="currentUser.picture">
                        <span class="user-name-small" x-text="currentUser.name || currentUser.email"></span>
                    </div>
                </template>
                <template x-if="currentUser">
                    <a href="/auth/logout" class="nav-item">
                        <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M15.75 9V5.25A2.25 2.25 0 0013.5 3h-6a2.25 2.25 0 00-2.25 2.25v13.5A2.25 2.25 0 007.5 21h6a2.25 2.25 0 002.25-2.25V15m3 0l3-3m0 0l-3-3m3 3H9"/>
                        </svg>
                        <span>Logout</span>
                    </a>
                </template>
            </div>
        </aside>

        <!-- Main area -->
        <div class="main-area">
            <!-- Topbar -->
            <header class="topbar">
                <div class="topbar-left">
                    <span class="h2" x-text="currentViewLabel"></span>
                </div>

                <div class="topbar-center">
                    <div class="search-box">
                        <input type="text"
                               class="search-input"
                               placeholder="Search papers..."
                               x-model="searchQuery"
                               @keyup.enter="searchPapers()"
                               @keyup.escape="searchQuery = ''">
                    </div>
                </div>

                <div class="topbar-right">
                    <button class="btn-icon" @click="refreshData()" title="Refresh">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                        </svg>
                    </button>
                </div>
            </header>

            <!-- Content -->
            <div class="content">
                <!-- Status Message -->
                <template x-if="statusMessage">
                    <div class="alert" :class="{
                        'alert-success': statusType === 'success',
                        'alert-error': statusType === 'error',
                        'alert-info': statusType === 'info'
                    }">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <div>
                                <div style="font-weight: 600; margin-bottom: 4px;" x-text="statusType === 'success' ? 'Success' : statusType === 'error' ? 'Not Found' : 'Processing...'"></div>
                                <div x-text="statusMessage"></div>
                                <template x-if="statusLinks && statusLinks.length > 0">
                                    <div style="margin-top: 8px; display: flex; flex-wrap: wrap; gap: 8px;">
                                        <template x-for="(link, i) in statusLinks.slice(0, 4)" :key="i">
                                            <a :href="link" target="_blank" class="search-link">
                                                Search <span x-text="i + 1"></span>
                                            </a>
                                        </template>
                                    </div>
                                </template>
                            </div>
                            <button @click="statusMessage = null; statusLinks = null" style="background: none; border: none; cursor: pointer; font-size: 1.25rem; color: inherit; opacity: 0.6;">&times;</button>
                        </div>
                    </div>
                </template>

                <!-- Job Status -->
                <template x-if="Object.keys(jobs).length > 0">
                    <div class="alert alert-warning">
                        <div style="font-weight: 600; margin-bottom: 8px;">Active Jobs</div>
                        <template x-for="(job, jobId) in jobs" :key="jobId">
                            <div class="job-progress">
                                <span style="font-family: var(--font-mono); font-size: 0.75rem;" x-text="jobId"></span>
                                <div class="job-progress-bar">
                                    <div class="job-progress-fill" :style="`width: ${(job.completed / job.total) * 100}%`"></div>
                                </div>
                                <span style="font-size: 0.75rem;" x-text="`${job.completed}/${job.total}`"></span>
                                <span class="status-badge" :class="job.status === 'completed' ? 'downloaded' : 'discovered'" x-text="job.status"></span>
                            </div>
                        </template>
                    </div>
                </template>

                <!-- Library View -->
                <template x-if="currentView === 'library'">
                    <div>
                        <!-- Stats Cards -->
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: var(--space-4); margin-bottom: var(--space-6); max-width: 500px;">
                            <div class="card stat-card" :class="{ active: currentFilter === 'discovered' }" @click="filterByStatus('discovered')">
                                <div class="stat-value" x-text="stats.by_status?.discovered || 0"></div>
                                <div class="stat-label">
                                    <span class="status-dot discovered" style="margin-right: 4px;"></span>
                                    <span>discovered</span>
                                </div>
                            </div>
                            <div class="card stat-card" :class="{ active: currentFilter === 'downloaded' }" @click="filterByStatus('downloaded')">
                                <div class="stat-value" x-text="stats.by_status?.downloaded || 0"></div>
                                <div class="stat-label">
                                    <span class="status-dot downloaded" style="margin-right: 4px;"></span>
                                    <span>downloaded</span>
                                </div>
                            </div>
                            <div class="card stat-card" :class="{ active: currentFilter === 'summarized' }" @click="filterByStatus('summarized')">
                                <div class="stat-value" x-text="stats.by_status?.summarized || 0"></div>
                                <div class="stat-label">
                                    <span class="status-dot summarized" style="margin-right: 4px;"></span>
                                    <span>summarized</span>
                                </div>
                            </div>
                        </div>

                        <!-- Actions Bar -->
                        <div class="actions-bar">
                            <button class="btn-secondary" :class="{ 'active': !currentFilter }" @click="clearFilter()">All Papers</button>
                        </div>

                        <!-- Papers Table -->
                        <div class="card" style="overflow: hidden;">
                            <table class="papers-table">
                                <thead>
                                    <tr>
                                        <th style="width: 32px;"></th>
                                        <th>Paper</th>
                                        <th style="width: 80px;">Year</th>
                                        <th style="width: 100px;">Status</th>
                                        <th style="width: 100px;">Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <template x-for="paper in papers" :key="paper.citekey">
                                        <tr class="paper-row" @click="viewPaperDetail(paper.citekey)">
                                            <td>
                                                <span class="status-dot" :class="paper.status"></span>
                                            </td>
                                            <td>
                                                <div class="paper-title" x-text="paper.title"></div>
                                                <div class="paper-authors" x-text="paper.authors?.join(', ')"></div>
                                                <div class="paper-citekey" x-text="paper.citekey"></div>
                                            </td>
                                            <td style="color: var(--text-muted);" x-text="paper.year || 'â€”'"></td>
                                            <td>
                                                <span class="status-badge" :class="paper.status" x-text="paper.status"></span>
                                            </td>
                                            <td @click.stop>
                                                <div class="paper-row-actions" style="opacity: 1;">
                                                    <template x-if="paper.pdf_path">
                                                        <a :href="`${apiBase}/api/papers/${paper.citekey}/pdf`" target="_blank" class="btn-text" style="padding: 4px;">PDF</a>
                                                    </template>
                                                    <template x-if="paper.status === 'discovered'">
                                                        <button @click="findPDFSingle(paper.citekey)" :disabled="loadingPaper === paper.citekey" class="btn-text" style="padding: 4px;">
                                                            <span x-show="loadingPaper !== paper.citekey">Find PDF</span>
                                                            <span x-show="loadingPaper === paper.citekey">...</span>
                                                        </button>
                                                    </template>
                                                </div>
                                            </td>
                                        </tr>
                                    </template>
                                </tbody>
                            </table>

                            <!-- Pagination -->
                            <div class="pagination">
                                <div class="pagination-info">
                                    Showing <span x-text="papers.length"></span> of <span x-text="totalPapers"></span> papers
                                </div>
                                <div class="pagination-buttons">
                                    <button class="btn-secondary" @click="prevPage()" :disabled="offset === 0">Previous</button>
                                    <button class="btn-secondary" @click="nextPage()" :disabled="offset + 100 >= totalPapers">Next</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </template>

                <!-- Network Graph View -->
                <template x-if="currentView === 'network'">
                    <div class="graph-container">
                        <div class="graph-toolbar">
                            <input type="text" placeholder="Search papers..." x-model="searchQuery" @keyup.enter="searchPapers()">
                        </div>

                        <div id="network-graph" class="graph-canvas"></div>

                        <div class="graph-connection-panel">
                            <h4>Connect Papers</h4>
                            <div class="connection-form">
                                <div class="form-group">
                                    <label>Source Paper</label>
                                    <input type="text" x-model="connectSource" placeholder="citekey">
                                </div>
                                <div class="form-group">
                                    <label>Target Paper</label>
                                    <input type="text" x-model="connectTarget" placeholder="citekey">
                                </div>
                                <div class="form-group">
                                    <label>Reason (optional)</label>
                                    <input type="text" x-model="connectReason" placeholder="Why related?">
                                </div>
                                <button class="btn-primary" @click="connectPapers()" :disabled="!connectSource || !connectTarget">
                                    Connect
                                </button>
                            </div>
                        </div>
                    </div>
                </template>

            </div>
        </div>
    </div>

    <!-- Paper Detail View (full page) -->
    <div class="paper-detail" x-show="showPaperDetail" x-cloak>
        <header class="paper-detail-header">
            <button class="btn-secondary" @click="closePaperDetail()">
                <span style="margin-right: 4px;">&larr;</span> Back
            </button>

            <!-- View Toggle (only show if PDF exists) -->
            <template x-if="paperDetail?.pdf_path">
                <div class="view-toggle">
                    <button :class="{ active: detailView === 'summary' }" @click="detailView = 'summary'">Summary</button>
                    <button :class="{ active: detailView === 'pdf' }" @click="switchToPdfView()">PDF</button>
                </div>
            </template>

            <div class="paper-detail-actions">
                <span class="status-badge" :class="paperDetail?.status" x-text="paperDetail?.status"></span>
                <template x-if="paperDetail?.status === 'discovered'">
                    <button class="btn-primary" @click="paperDetailAction('find-pdf')">Find PDF</button>
                </template>
                <template x-if="paperDetail?.status === 'downloaded' || paperDetail?.status === 'summarized'">
                    <button class="btn-primary" @click="paperDetailAction('summarize')" x-text="paperDetail?.status === 'summarized' ? 'Re-summarize' : 'Summarize'"></button>
                </template>
                <template x-if="paperDetail?.pdf_path && detailView === 'summary'">
                    <a :href="`${apiBase}/api/papers/${paperDetail.citekey}/pdf`" target="_blank" class="btn-secondary">
                        Open PDF
                    </a>
                </template>
            </div>
        </header>

        <div class="paper-detail-content">
            <!-- Summary View -->
            <template x-if="detailView === 'summary'">
                <!-- Left margin rail -->
                <aside class="paper-margin">
                    <div class="margin-section">
                        <span class="margin-label">Year</span>
                        <span class="margin-value" x-text="paperDetail?.year || 'â€”'"></span>
                    </div>
                    <div class="margin-section">
                        <span class="margin-label">Journal</span>
                        <span class="margin-value" x-text="paperDetail?.journal || 'Working Paper'"></span>
                    </div>
                    <div class="margin-section">
                        <span class="margin-label">Citekey</span>
                        <code class="margin-value font-mono" style="font-size: 0.75rem;" x-text="paperDetail?.citekey"></code>
                    </div>
                    <template x-if="paperDetail?.doi">
                        <div class="margin-section">
                            <span class="margin-label">DOI</span>
                            <a :href="'https://doi.org/' + paperDetail.doi" class="margin-link" x-text="paperDetail.doi" target="_blank"></a>
                        </div>
                    </template>
                    <template x-if="paperDetail?.url">
                        <div class="margin-section">
                            <span class="margin-label">URL</span>
                            <a :href="paperDetail.url" class="margin-link" target="_blank">Link</a>
                        </div>
                    </template>
                    <template x-if="paperDetail?.added_at">
                        <div class="margin-section">
                            <span class="margin-label">Added</span>
                            <span class="margin-value" x-text="new Date(paperDetail.added_at).toLocaleDateString()"></span>
                        </div>
                    </template>
                </aside>

                <!-- Main reading area -->
                <main class="paper-main">
                    <h1 class="h1" x-text="paperDetail?.title"></h1>
                    <p class="paper-authors-full" x-text="paperDetail?.authors?.join(', ')"></p>

                    <!-- BibTeX Citation -->
                    <div class="citation-block">
                        <div class="citation-block-header">BibTeX Citation</div>
                        <template x-if="paperDetail?.bibtex">
                            <pre x-text="paperDetail.bibtex"></pre>
                        </template>
                        <template x-if="!paperDetail?.bibtex">
                            <pre x-text="formatBibtex(paperDetail)"></pre>
                        </template>
                    </div>

                    <!-- Abstract -->
                    <template x-if="paperDetail?.abstract">
                        <section class="paper-section">
                            <h2 class="h2">Abstract</h2>
                            <p class="body-reading" x-text="paperDetail.abstract"></p>
                        </section>
                    </template>

                    <!-- Summary -->
                    <template x-if="paperSummary">
                        <section class="paper-section">
                            <h2 class="h2">Summary</h2>
                            <div class="body-reading summary-content markdown-body" x-html="renderMarkdown(paperSummary)"></div>
                        </section>
                    </template>

                    <!-- Related Papers -->
                    <template x-if="paperDetail?.related_papers?.length > 0">
                        <section class="paper-section">
                            <h2 class="h2">Related Papers</h2>
                            <template x-for="related in paperDetail.related_papers" :key="related.title">
                                <div class="related-paper-card">
                                    <div class="related-paper-title" x-text="related.title"></div>
                                    <div class="related-paper-meta">
                                        <span x-text="related.authors?.join(', ') || 'Unknown authors'"></span>
                                        (<span x-text="related.year || 'n.d.'"></span>)
                                    </div>
                                    <div class="related-paper-reason" x-text="related.why_related"></div>
                                    <div class="related-paper-actions">
                                        <template x-if="related.vault_citekey">
                                            <button @click="viewPaperDetail(related.vault_citekey)" class="link-btn">
                                                View in Library
                                            </button>
                                        </template>
                                        <template x-if="!related.vault_citekey">
                                            <button @click="addRelatedPaper(related)" class="link-btn">
                                                + Add to Library
                                            </button>
                                        </template>
                                    </div>
                                </div>
                            </template>
                        </section>
                    </template>
                </main>
            </template>

            <!-- PDF View -->
            <template x-if="detailView === 'pdf'">
                <div class="pdf-viewer-container">
                    <!-- PDF Toolbar -->
                    <div class="pdf-toolbar">
                        <button @click="pdfPrevPage()" :disabled="pdfCurrentPage <= 1">&#8592; Prev</button>
                        <span class="pdf-page-info">Page <span x-text="pdfCurrentPage"></span> of <span x-text="pdfTotalPages"></span></span>
                        <button @click="pdfNextPage()" :disabled="pdfCurrentPage >= pdfTotalPages">Next &#8594;</button>

                        <div class="highlight-colors">
                            <div class="highlight-color yellow" :class="{ active: highlightColor === 'yellow' }" @click="highlightColor = 'yellow'" title="Yellow"></div>
                            <div class="highlight-color green" :class="{ active: highlightColor === 'green' }" @click="highlightColor = 'green'" title="Green"></div>
                            <div class="highlight-color blue" :class="{ active: highlightColor === 'blue' }" @click="highlightColor = 'blue'" title="Blue"></div>
                            <div class="highlight-color pink" :class="{ active: highlightColor === 'pink' }" @click="highlightColor = 'pink'" title="Pink"></div>
                        </div>

                        <button @click="createHighlightFromSelection()">Highlight Selection</button>
                    </div>

                    <!-- PDF Canvas -->
                    <div class="pdf-canvas-container">
                        <div class="pdf-page-wrapper">
                            <canvas id="pdf-canvas" class="pdf-canvas"></canvas>
                            <div id="pdf-text-layer" class="pdf-text-layer"></div>
                            <div id="pdf-highlight-layer" class="pdf-highlight-layer">
                                <template x-for="h in currentPageHighlights" :key="h.id">
                                    <template x-for="(rect, i) in h.rects" :key="i">
                                        <div class="pdf-highlight"
                                             :class="h.color"
                                             :style="`left: ${rect.x * 100}%; top: ${rect.y * 100}%; width: ${rect.width * 100}%; height: ${rect.height * 100}%;`"
                                             @click="showHighlightNote(h)"
                                             :title="h.note || h.text"></div>
                                    </template>
                                </template>
                            </div>
                        </div>
                    </div>
                </div>
            </template>

            <!-- Notes Panel (shows in both views when PDF exists) -->
            <template x-if="paperDetail?.pdf_path && detailView === 'pdf'">
                <aside class="notes-panel">
                    <div class="notes-panel-header">
                        <h3>Notes</h3>
                        <button class="btn-secondary" style="font-size: 0.75rem; padding: 4px 8px;" @click="saveNotes()" :disabled="!notesModified">
                            <span x-show="!savingNotes">Save</span>
                            <span x-show="savingNotes">Saving...</span>
                        </button>
                    </div>

                    <div class="notes-tabs">
                        <button class="notes-tab" :class="{ active: notesTab === 'notes' }" @click="notesTab = 'notes'">Notes</button>
                        <button class="notes-tab" :class="{ active: notesTab === 'highlights' }" @click="notesTab = 'highlights'">
                            Highlights (<span x-text="paperHighlights.length"></span>)
                        </button>
                    </div>

                    <div class="notes-content">
                        <!-- Notes Tab -->
                        <template x-if="notesTab === 'notes'">
                            <div>
                                <textarea class="notes-textarea"
                                          x-model="paperNotesContent"
                                          @input="notesModified = true"
                                          placeholder="Write notes here... Supports LaTeX: $E = mc^2$"></textarea>
                                <div class="notes-preview" x-html="renderNotesPreview(paperNotesContent)"></div>
                            </div>
                        </template>

                        <!-- Highlights Tab -->
                        <template x-if="notesTab === 'highlights'">
                            <div class="highlights-list">
                                <template x-if="paperHighlights.length === 0">
                                    <p style="color: var(--text-muted); font-size: 0.875rem;">No highlights yet. Select text in the PDF and click "Highlight Selection".</p>
                                </template>
                                <template x-for="h in paperHighlights" :key="h.id">
                                    <div class="highlight-item" :class="h.color">
                                        <div class="highlight-item-text" x-text="h.text || '(No text)'"></div>
                                        <template x-if="h.note">
                                            <div style="font-size: 0.8125rem; font-style: italic; margin-top: 4px; color: var(--text-muted);" x-text="h.note"></div>
                                        </template>
                                        <div class="highlight-item-meta">
                                            <span>Page <span x-text="h.page"></span></span>
                                            <button class="highlight-item-delete" @click="deleteHighlight(h.id)">Delete</button>
                                        </div>
                                    </div>
                                </template>
                            </div>
                        </template>
                    </div>
                </aside>
            </template>
        </div>
    </div>

    <!-- Import Modal -->
    <div class="modal-overlay" x-show="showImportModal" x-cloak @click.self="showImportModal = false">
        <div class="modal">
            <div class="modal-header">
                <h3 class="h3">Import BibTeX</h3>
                <button @click="showImportModal = false" style="background: none; border: none; cursor: pointer; font-size: 1.25rem;">&times;</button>
            </div>
            <div class="modal-body">
                <template x-if="importMessage">
                    <div class="alert" :class="importMessageType === 'success' ? 'alert-success' : importMessageType === 'info' ? 'alert-info' : 'alert-error'" style="margin-bottom: var(--space-4);">
                        <span x-text="importMessage"></span>
                    </div>
                </template>

                <div style="margin-bottom: var(--space-6);">
                    <label class="h2" style="display: block; margin-bottom: var(--space-2);">Upload File</label>
                    <label class="btn-primary" style="cursor: pointer; display: inline-block;" :style="importing ? 'opacity: 0.5; pointer-events: none;' : ''">
                        <span x-show="!importing">Choose .bib File</span>
                        <span x-show="importing">Importing...</span>
                        <input type="file" accept=".bib" @change="importBibtex($event)" style="display: none;" :disabled="importing">
                    </label>
                </div>
                <div>
                    <label class="h2" style="display: block; margin-bottom: var(--space-2);">Or Enter Path</label>
                    <div class="input-with-browse">
                        <input type="text" x-model="importPath"
                               placeholder="/path/to/references.bib"
                               class="search-input">
                        <button class="btn-browse" @click="openBrowse('import')">Browse</button>
                    </div>
                    <div style="margin-top: var(--space-3);">
                        <button class="btn-primary" @click="importFromPath()" :disabled="!importPath || importing">
                            <span x-show="!importing">Import</span>
                            <span x-show="importing">Importing...</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Sync Modal -->
    <div class="modal-overlay" x-show="showSyncModal" x-cloak @click.self="showSyncModal = false">
        <div class="modal">
            <div class="modal-header">
                <h3 class="h3">Sync to Folder</h3>
                <button @click="showSyncModal = false" style="background: none; border: none; cursor: pointer; font-size: 1.25rem;">&times;</button>
            </div>
            <div class="modal-body">
                <p style="color: var(--text-muted); margin-bottom: var(--space-4); font-size: 0.875rem;">
                    Export your library to a local folder. This will copy PDFs, summaries, and generate a merged BibTeX file.
                </p>

                <div style="margin-bottom: var(--space-4); padding: var(--space-3); background: var(--surface); border-radius: 6px; font-size: 0.8125rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <span style="color: var(--text-muted);">Source:</span>
                            <code style="font-family: var(--font-mono); font-size: 0.75rem;" x-text="sourceBibPath || 'Not set'"></code>
                        </div>
                        <button class="btn-browse" style="font-size: 0.75rem; padding: 4px 8px;" @click="openBrowse('source')">Set</button>
                    </div>
                </div>

                <div style="margin-bottom: var(--space-4);">
                    <label class="h2" style="display: block; margin-bottom: var(--space-2);">Export Folder</label>
                    <div class="input-with-browse">
                        <input type="text" x-model="syncPath"
                               placeholder="~/Documents/MyLibrary"
                               class="search-input">
                        <button class="btn-browse" @click="openBrowse('sync')">Browse</button>
                    </div>
                </div>

                <div style="margin-bottom: var(--space-6);">
                    <label class="h2" style="display: block; margin-bottom: var(--space-2);">Include</label>
                    <label style="display: flex; align-items: center; gap: var(--space-2); margin-bottom: var(--space-2); cursor: pointer;">
                        <input type="checkbox" x-model="syncOptions.pdfs">
                        <span>PDFs (<span x-text="stats.by_status?.downloaded || 0"></span> + <span x-text="stats.by_status?.summarized || 0"></span> files)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: var(--space-2); margin-bottom: var(--space-2); cursor: pointer;">
                        <input type="checkbox" x-model="syncOptions.summaries">
                        <span>Summaries (<span x-text="stats.by_status?.summarized || 0"></span> files)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: var(--space-2); cursor: pointer;">
                        <input type="checkbox" x-model="syncOptions.bibtex">
                        <span>BibTeX (references.bib)</span>
                    </label>
                </div>

                <template x-if="syncResult">
                    <div class="alert" :class="syncResult.success ? 'alert-success' : 'alert-error'" style="margin-bottom: var(--space-4);">
                        <template x-if="syncResult.success">
                            <div>
                                <div style="font-weight: 600; margin-bottom: 4px;">Sync Complete</div>
                                <div style="font-size: 0.875rem;">
                                    <span x-text="syncResult.pdfs_copied"></span> PDFs,
                                    <span x-text="syncResult.summaries_copied"></span> summaries exported
                                </div>
                            </div>
                        </template>
                        <template x-if="!syncResult.success">
                            <div x-text="syncResult.error"></div>
                        </template>
                    </div>
                </template>

                <div style="display: flex; gap: var(--space-3);">
                    <button class="btn-primary" @click="syncToFolder()" :disabled="!syncPath || syncing">
                        <span x-show="!syncing">Sync Now</span>
                        <span x-show="syncing">Syncing...</span>
                    </button>
                    <a :href="`${apiBase}/api/export-bibtex`" download="references.bib" class="btn-secondary" style="text-decoration: none;">
                        Download BibTeX Only
                    </a>
                </div>
            </div>
        </div>
    </div>

    <!-- Browse Modal -->
    <div class="modal-overlay" x-show="showBrowseModal" x-cloak @click.self="showBrowseModal = false">
        <div class="modal">
            <div class="modal-header">
                <h3 class="h3" x-text="browseMode === 'import' ? 'Select .bib File' : browseMode === 'source' ? 'Set Source .bib' : 'Select Folder'"></h3>
                <button @click="showBrowseModal = false" style="background: none; border: none; cursor: pointer; font-size: 1.25rem;">&times;</button>
            </div>
            <div class="modal-body">
                <div class="browse-current" x-text="browseCurrent"></div>

                <div class="browse-list">
                    <template x-if="browseParent">
                        <div class="browse-item parent" @click="browseTo(browseParent)">
                            <span class="icon">..</span>
                            <span>Parent folder</span>
                        </div>
                    </template>

                    <template x-for="dir in browseDirectories" :key="dir.path">
                        <div class="browse-item" @click="browseTo(dir.path)">
                            <span class="icon">ðŸ“</span>
                            <span x-text="dir.name"></span>
                        </div>
                    </template>

                    <template x-if="browseMode === 'import' || browseMode === 'source'">
                        <template x-for="file in browseBibFiles" :key="file.path">
                            <div class="browse-item" @click="selectBrowsePath(file.path)" style="color: var(--accent);">
                                <span class="icon">ðŸ“„</span>
                                <span x-text="file.name"></span>
                            </div>
                        </template>
                    </template>
                </div>

                <div style="display: flex; gap: var(--space-3);">
                    <template x-if="browseMode === 'sync'">
                        <button class="btn-primary" @click="selectBrowsePath(browseCurrent)">
                            Select This Folder
                        </button>
                    </template>
                    <button class="btn-secondary" @click="showBrowseModal = false">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        window.MARGINALIA_API_BASE = window.MARGINALIA_API_BASE || '';

        function app() {
            return {
                apiBase: window.MARGINALIA_API_BASE,
                stats: { by_status: {} },
                papers: [],
                totalPapers: 0,
                offset: 0,
                searchQuery: '',
                currentFilter: null,
                jobs: {},
                jobPollInterval: null,

                // UI state
                currentView: 'library',  // 'library' or 'network'
                showImportModal: false,
                showSyncModal: false,
                showPaperDetail: false,
                paperDetail: null,
                paperSummary: null,

                // Status message
                statusMessage: null,
                statusType: 'info',
                statusLinks: null,
                loadingPaper: null,
                importPath: '',
                importMessage: null,
                importMessageType: 'info',
                importing: false,

                // Sync state
                syncPath: '',
                sourceBibPath: null,
                syncOptions: { pdfs: true, summaries: true, bibtex: true },
                syncing: false,
                syncResult: null,

                // Browse state
                showBrowseModal: false,
                browseMode: null,  // 'import', 'source', or 'sync'
                browseCurrent: '',
                browseParent: null,
                browseDirectories: [],
                browseBibFiles: [],

                // Auth state
                currentUser: null,

                // PDF viewer state
                detailView: 'summary',  // 'summary' or 'pdf'
                pdfDoc: null,
                pdfCurrentPage: 1,
                pdfTotalPages: 0,
                highlightColor: 'yellow',

                // Notes state
                notesTab: 'notes',  // 'notes' or 'highlights'
                paperNotesContent: '',
                paperHighlights: [],
                notesModified: false,
                savingNotes: false,

                // Network graph state
                networkGraph: null,
                networkNodes: [],
                networkEdges: [],
                connectSource: '',
                connectTarget: '',
                connectReason: '',

                get currentViewLabel() {
                    return this.currentView === 'network' ? 'Network Graph' : 'Library';
                },

                formatBibtex(paper) {
                    if (!paper) return '';
                    const type = paper.journal ? 'article' : 'misc';
                    const authors = paper.authors?.join(' and ') || 'Unknown';
                    let bib = `@${type}{${paper.citekey},\n`;
                    bib += `  author = {${authors}},\n`;
                    bib += `  title = {${paper.title || ''}},\n`;
                    if (paper.journal) bib += `  journal = {${paper.journal}},\n`;
                    if (paper.year) bib += `  year = {${paper.year}},\n`;
                    if (paper.doi) bib += `  doi = {${paper.doi}},\n`;
                    if (paper.url) bib += `  url = {${paper.url}},\n`;
                    bib += `}`;
                    return bib;
                },

                renderMarkdown(text) {
                    if (!text) return '';
                    try {
                        let processed = text;

                        // Strip metadata frontmatter block (title: "..." authors: [...] etc.)
                        processed = processed.replace(/^title:\s*"[^"]*"\s*authors:\s*\[[^\]]*\]\s*year:\s*\d*\s*journal:\s*"[^"]*"\s*citekey:\s*"[^"]*"\s*doi:\s*"[^"]*"\s*status:\s*"[^"]*"\s*pdf_path:\s*"[^"]*"\s*/i, '');

                        // Also strip YAML-style frontmatter between --- markers
                        processed = processed.replace(/^---[\s\S]*?---\s*/m, '');

                        // Strip leading "# Summary" or "## Summary" heading (we already have section header)
                        processed = processed.replace(/^##?\s*Summary\s*\n+/i, '');

                        // Strip "Related Work" or "Related Papers" sections from the summary text
                        // (we show these as separate linked cards, not prose)
                        processed = processed.replace(/##?\s*Related\s*(Work|Papers|Literature)[\s\S]*$/i, '');

                        // Convert wiki-links [[filename]] to actual links
                        // [[paper.pdf]] -> link to the paper's PDF
                        processed = processed.replace(/\[\[([^\]]+\.pdf)\]\]/gi, (match, filename) => {
                            if (this.paperDetail?.pdf_path) {
                                return `[Open PDF](${this.apiBase}/api/papers/${this.paperDetail.citekey}/pdf)`;
                            }
                            return match;
                        });
                        // Convert other wiki-links [[citekey]] to paper links (if they exist)
                        processed = processed.replace(/\[\[([^\]]+)\]\]/g, (match, content) => {
                            // Just render as emphasized text if not a PDF link
                            return `*${content}*`;
                        });
                        return marked.parse(processed);
                    } catch (e) {
                        return text;
                    }
                },

                async init() {
                    await this.checkAuth();
                    await this.refreshData();
                    await this.loadConfig();
                    this.startJobPolling();
                },

                async checkAuth() {
                    try {
                        const res = await fetch(`${this.apiBase}/api/me`);
                        const data = await res.json();
                        if (data.authenticated) {
                            this.currentUser = data.user;
                        }
                    } catch (e) {
                        console.log('Auth check failed:', e);
                    }
                },

                async loadConfig() {
                    try {
                        const res = await fetch(`${this.apiBase}/api/config`);
                        const config = await res.json();
                        if (config.default_sync_path) {
                            this.syncPath = config.default_sync_path;
                        }
                        if (config.source_bib_path) {
                            this.sourceBibPath = config.source_bib_path;
                        }
                    } catch (e) {
                        console.log('Could not load config:', e);
                    }
                },

                async openBrowse(mode) {
                    this.browseMode = mode;
                    // Start from current path or home
                    let startPath = null;
                    if (mode === 'import' && this.importPath) {
                        startPath = this.importPath.split('/').slice(0, -1).join('/');
                    } else if (mode === 'source' && this.sourceBibPath) {
                        startPath = this.sourceBibPath.split('/').slice(0, -1).join('/');
                    } else if (mode === 'sync' && this.syncPath) {
                        startPath = this.syncPath;
                    }
                    await this.browseTo(startPath);
                    this.showBrowseModal = true;
                },

                async browseTo(path) {
                    try {
                        const res = await fetch(`${this.apiBase}/api/browse`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ path: path })
                        });
                        const data = await res.json();
                        this.browseCurrent = data.current;
                        this.browseParent = data.parent;
                        this.browseDirectories = data.directories;
                        this.browseBibFiles = data.bib_files || [];
                    } catch (e) {
                        console.error('Browse error:', e);
                    }
                },

                async selectBrowsePath(path) {
                    if (this.browseMode === 'import') {
                        this.importPath = path;
                    } else if (this.browseMode === 'source') {
                        // Set the source path via API
                        try {
                            const res = await fetch(`${this.apiBase}/api/config/source-path`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ source_path: path })
                            });
                            const data = await res.json();
                            this.sourceBibPath = data.source_bib_path;
                            // Also set sync path to parent directory
                            const pathParts = path.split('/');
                            pathParts.pop();
                            this.syncPath = pathParts.join('/');
                        } catch (e) {
                            console.error('Error setting source path:', e);
                        }
                    } else if (this.browseMode === 'sync') {
                        this.syncPath = path;
                    }
                    this.showBrowseModal = false;
                },

                async refreshData() {
                    await this.refreshStats();
                    await this.loadPapers();
                },

                async refreshStats() {
                    const res = await fetch(`${this.apiBase}/api/stats`);
                    this.stats = await res.json();
                },

                async loadPapers() {
                    let url = `${this.apiBase}/api/papers?limit=100&offset=${this.offset}`;
                    if (this.currentFilter) url += `&status=${this.currentFilter}`;
                    if (this.searchQuery) url += `&search=${encodeURIComponent(this.searchQuery)}`;

                    const res = await fetch(url);
                    const data = await res.json();
                    this.papers = data.papers;
                    this.totalPapers = data.total;
                },

                filterByStatus(status) {
                    this.currentFilter = this.currentFilter === status ? null : status;
                    this.offset = 0;
                    this.loadPapers();
                },

                clearFilter() {
                    this.currentFilter = null;
                    this.searchQuery = '';
                    this.offset = 0;
                    this.loadPapers();
                },

                searchPapers() {
                    this.currentFilter = null;
                    this.offset = 0;
                    this.loadPapers();
                },

                prevPage() {
                    this.offset = Math.max(0, this.offset - 100);
                    this.loadPapers();
                },

                nextPage() {
                    this.offset += 100;
                    this.loadPapers();
                },

                async findPDFSingle(citekey) {
                    this.loadingPaper = citekey;
                    this.statusMessage = `Searching for PDF...`;
                    this.statusType = 'info';
                    this.statusLinks = null;

                    try {
                        const res = await fetch(`${this.apiBase}/api/papers/${citekey}/find-pdf`, { method: 'POST' });
                        const data = await res.json();

                        if (data.status === 'success') {
                            this.statusMessage = `PDF found from ${data.source}!`;
                            this.statusType = 'success';
                        } else {
                            this.statusMessage = `No open access PDF found. Try the manual search links.`;
                            this.statusType = 'error';
                            this.statusLinks = data.manual_links || [];
                        }

                        await this.refreshData();
                    } catch (e) {
                        this.statusMessage = `Error: ${e.message}`;
                        this.statusType = 'error';
                    } finally {
                        this.loadingPaper = null;
                    }
                },

                async summarizeSinglePaper(citekey) {
                    this.loadingPaper = citekey;
                    this.statusMessage = `Summarizing ${citekey}...`;
                    this.statusType = 'info';
                    this.statusLinks = null;

                    try {
                        const res = await fetch(`${this.apiBase}/api/papers/${citekey}/summarize`, { method: 'POST' });
                        const data = await res.json();

                        if (res.ok) {
                            this.statusMessage = `Successfully summarized!`;
                            this.statusType = 'success';
                            await this.refreshData();
                        } else {
                            this.statusMessage = `Error: ${data.detail}`;
                            this.statusType = 'error';
                        }
                    } catch (e) {
                        this.statusMessage = `Error: ${e.message}`;
                        this.statusType = 'error';
                    } finally {
                        this.loadingPaper = null;
                    }
                },

                startJobPolling() {
                    this.jobPollInterval = setInterval(async () => {
                        const res = await fetch(`${this.apiBase}/api/jobs`);
                        this.jobs = await res.json();

                        const hasCompleted = Object.values(this.jobs).some(j => j.status === 'completed');
                        if (hasCompleted) {
                            await this.refreshData();
                        }
                    }, 2000);
                },

                async uploadPDF(citekey, event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    const formData = new FormData();
                    formData.append('file', file);

                    await fetch(`${this.apiBase}/api/papers/${citekey}/upload-pdf`, {
                        method: 'POST',
                        body: formData
                    });

                    await this.refreshData();
                },

                async importBibtex(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    this.importing = true;
                    this.importMessage = 'Importing...';
                    this.importMessageType = 'info';

                    try {
                        const formData = new FormData();
                        formData.append('file', file);

                        const res = await fetch(`${this.apiBase}/api/import-bibtex`, {
                            method: 'POST',
                            body: formData
                        });
                        const data = await res.json();

                        this.importMessage = `Imported ${data.added} papers`;
                        this.importMessageType = 'success';
                        await this.refreshData();
                    } catch (e) {
                        this.importMessage = `Error: ${e.message}`;
                        this.importMessageType = 'error';
                    } finally {
                        this.importing = false;
                    }
                },

                async importFromPath() {
                    if (!this.importPath) return;

                    this.importing = true;
                    this.importMessage = 'Importing...';
                    this.importMessageType = 'info';

                    try {
                        const res = await fetch(`${this.apiBase}/api/import-bibtex-path`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ file_path: this.importPath })
                        });
                        const data = await res.json();

                        if (res.ok) {
                            this.importMessage = `Imported ${data.added} papers`;
                            this.importMessageType = 'success';
                            // Set sync path to parent directory of imported .bib
                            if (data.source_path) {
                                this.sourceBibPath = data.source_path;
                                const pathParts = data.source_path.split('/');
                                pathParts.pop(); // Remove filename
                                this.syncPath = pathParts.join('/');
                            }
                            await this.refreshData();
                        } else {
                            this.importMessage = `Error: ${data.detail}`;
                            this.importMessageType = 'error';
                        }
                    } catch (e) {
                        this.importMessage = `Error: ${e.message}`;
                        this.importMessageType = 'error';
                    } finally {
                        this.importing = false;
                    }
                },

                async syncToFolder() {
                    if (!this.syncPath) return;

                    this.syncing = true;
                    this.syncResult = null;

                    try {
                        const res = await fetch(`${this.apiBase}/api/sync`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder_path: this.syncPath,
                                include_pdfs: this.syncOptions.pdfs,
                                include_summaries: this.syncOptions.summaries,
                                include_bibtex: this.syncOptions.bibtex
                            })
                        });
                        const data = await res.json();

                        if (res.ok) {
                            this.syncResult = { success: true, ...data };
                        } else {
                            this.syncResult = { success: false, error: data.detail };
                        }
                    } catch (e) {
                        this.syncResult = { success: false, error: e.message };
                    } finally {
                        this.syncing = false;
                    }
                },

                async viewPaperDetail(citekey) {
                    const res = await fetch(`${this.apiBase}/api/papers/${citekey}`);
                    this.paperDetail = await res.json();
                    this.paperSummary = null;
                    this.detailView = 'summary';
                    this.pdfDoc = null;
                    this.pdfCurrentPage = 1;
                    this.pdfTotalPages = 0;
                    this.paperNotesContent = '';
                    this.paperHighlights = [];
                    this.notesModified = false;

                    if (this.paperDetail.status === 'summarized') {
                        try {
                            const summaryRes = await fetch(`${this.apiBase}/api/papers/${citekey}/summary`);
                            const summaryData = await summaryRes.json();
                            this.paperSummary = summaryData.content;
                        } catch (e) {
                            console.log('Could not load summary:', e);
                        }
                    }

                    // Load notes if available
                    if (this.paperDetail.pdf_path) {
                        await this.loadPaperNotes(citekey);
                    }

                    this.showPaperDetail = true;
                },

                closePaperDetail() {
                    this.showPaperDetail = false;
                    this.paperDetail = null;
                    this.paperSummary = null;
                    this.detailView = 'summary';
                    this.pdfDoc = null;
                    this.pdfCurrentPage = 1;
                    this.pdfTotalPages = 0;
                    this.paperNotesContent = '';
                    this.paperHighlights = [];
                    this.notesModified = false;
                },

                async addRelatedPaper(related) {
                    try {
                        const res = await fetch(`${this.apiBase}/api/papers/add-related`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                title: related.title,
                                authors: related.authors,
                                year: related.year,
                                source_citekey: this.paperDetail.citekey
                            })
                        });
                        const data = await res.json();

                        if (data.status === 'added') {
                            this.statusMessage = `Added "${related.title.substring(0, 50)}..." to library`;
                            this.statusType = 'success';
                            related.vault_citekey = data.citekey;
                            await this.refreshData();
                        } else if (data.status === 'exists') {
                            this.statusMessage = `Paper already exists in library`;
                            this.statusType = 'info';
                            related.vault_citekey = data.citekey;
                        }
                    } catch (e) {
                        this.statusMessage = `Error: ${e.message}`;
                        this.statusType = 'error';
                    }
                },

                async paperDetailAction(action) {
                    if (!this.paperDetail) return;
                    const citekey = this.paperDetail.citekey;

                    if (action === 'find-pdf') {
                        await this.findPDFSingle(citekey);
                        await this.viewPaperDetail(citekey);
                    } else if (action === 'summarize') {
                        await this.summarizeSinglePaper(citekey);
                        await this.viewPaperDetail(citekey);
                    }
                },

                // PDF Viewer Methods

                get currentPageHighlights() {
                    return this.paperHighlights.filter(h => h.page === this.pdfCurrentPage);
                },

                async switchToPdfView() {
                    this.detailView = 'pdf';
                    await this.$nextTick();
                    await this.loadPdf();
                },

                async loadPdf() {
                    if (!this.paperDetail?.pdf_path) return;

                    const pdfUrl = `${this.apiBase}/api/papers/${this.paperDetail.citekey}/pdf`;

                    try {
                        if (typeof pdfjsLib === 'undefined') {
                            console.error('PDF.js not loaded');
                            return;
                        }

                        const loadingTask = pdfjsLib.getDocument(pdfUrl);
                        this.pdfDoc = await loadingTask.promise;
                        this.pdfTotalPages = this.pdfDoc.numPages;
                        this.pdfCurrentPage = 1;
                        await this.renderPdfPage(1);
                    } catch (e) {
                        console.error('Error loading PDF:', e);
                    }
                },

                async renderPdfPage(pageNum) {
                    if (!this.pdfDoc) return;

                    const page = await this.pdfDoc.getPage(pageNum);
                    const scale = 1.5;
                    const viewport = page.getViewport({ scale });

                    const canvas = document.getElementById('pdf-canvas');
                    const ctx = canvas.getContext('2d');

                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    await page.render({
                        canvasContext: ctx,
                        viewport: viewport
                    }).promise;

                    // Render text layer for selection
                    const textContent = await page.getTextContent();
                    const textLayer = document.getElementById('pdf-text-layer');
                    textLayer.innerHTML = '';
                    textLayer.style.width = `${viewport.width}px`;
                    textLayer.style.height = `${viewport.height}px`;

                    // Render text spans using viewport transform
                    textContent.items.forEach((item) => {
                        const span = document.createElement('span');

                        // Calculate position from transform matrix
                        const tx = item.transform;
                        const x = tx[4] * scale;
                        const y = viewport.height - (tx[5] * scale);

                        span.textContent = item.str;
                        span.style.left = `${x}px`;
                        span.style.top = `${y - (item.height * scale)}px`;
                        span.style.fontSize = `${item.height * scale}px`;
                        span.style.fontFamily = item.fontName || 'sans-serif';

                        textLayer.appendChild(span);
                    });
                },

                async pdfPrevPage() {
                    if (this.pdfCurrentPage > 1) {
                        this.pdfCurrentPage--;
                        await this.renderPdfPage(this.pdfCurrentPage);
                    }
                },

                async pdfNextPage() {
                    if (this.pdfCurrentPage < this.pdfTotalPages) {
                        this.pdfCurrentPage++;
                        await this.renderPdfPage(this.pdfCurrentPage);
                    }
                },

                // Notes Methods

                async loadPaperNotes(citekey) {
                    try {
                        const res = await fetch(`${this.apiBase}/api/papers/${citekey}/notes`);
                        const data = await res.json();
                        this.paperNotesContent = data.content || '';
                        this.paperHighlights = data.highlights || [];
                    } catch (e) {
                        console.log('Could not load notes:', e);
                    }
                },

                async saveNotes() {
                    if (!this.paperDetail) return;

                    this.savingNotes = true;
                    try {
                        await fetch(`${this.apiBase}/api/papers/${this.paperDetail.citekey}/notes`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ content: this.paperNotesContent })
                        });
                        this.notesModified = false;
                    } catch (e) {
                        console.error('Error saving notes:', e);
                    } finally {
                        this.savingNotes = false;
                    }
                },

                async createHighlightFromSelection() {
                    const selection = window.getSelection();
                    if (!selection || selection.isCollapsed) {
                        alert('Please select text in the PDF first.');
                        return;
                    }

                    const selectedText = selection.toString();
                    if (!selectedText.trim()) {
                        alert('Please select text in the PDF first.');
                        return;
                    }

                    // Get selection bounds relative to canvas
                    const canvas = document.getElementById('pdf-canvas');
                    const canvasRect = canvas.getBoundingClientRect();
                    const range = selection.getRangeAt(0);
                    const rects = range.getClientRects();

                    const normalizedRects = [];
                    for (let i = 0; i < rects.length; i++) {
                        const rect = rects[i];
                        normalizedRects.push({
                            x: (rect.left - canvasRect.left) / canvasRect.width,
                            y: (rect.top - canvasRect.top) / canvasRect.height,
                            width: rect.width / canvasRect.width,
                            height: rect.height / canvasRect.height
                        });
                    }

                    // Create highlight via API
                    try {
                        const res = await fetch(`${this.apiBase}/api/papers/${this.paperDetail.citekey}/highlights`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                page: this.pdfCurrentPage,
                                rects: normalizedRects,
                                text: selectedText,
                                color: this.highlightColor
                            })
                        });
                        const data = await res.json();

                        // Add to local state
                        this.paperHighlights.push({
                            id: data.highlight_id,
                            page: this.pdfCurrentPage,
                            rects: normalizedRects,
                            text: selectedText,
                            color: this.highlightColor
                        });

                        // Clear selection
                        selection.removeAllRanges();
                    } catch (e) {
                        console.error('Error creating highlight:', e);
                    }
                },

                async deleteHighlight(highlightId) {
                    if (!confirm('Delete this highlight?')) return;

                    try {
                        await fetch(`${this.apiBase}/api/papers/${this.paperDetail.citekey}/highlights/${highlightId}`, {
                            method: 'DELETE'
                        });
                        this.paperHighlights = this.paperHighlights.filter(h => h.id !== highlightId);
                    } catch (e) {
                        console.error('Error deleting highlight:', e);
                    }
                },

                showHighlightNote(highlight) {
                    if (highlight.note) {
                        alert(highlight.note);
                    }
                },

                renderNotesPreview(content) {
                    if (!content) return '<p style="color: var(--text-muted);">Preview will appear here...</p>';

                    // First render markdown
                    let html = marked.parse(content);

                    // Then render KaTeX (if available)
                    if (typeof renderMathInElement !== 'undefined') {
                        const temp = document.createElement('div');
                        temp.innerHTML = html;
                        renderMathInElement(temp, {
                            delimiters: [
                                { left: '$$', right: '$$', display: true },
                                { left: '$', right: '$', display: false }
                            ],
                            throwOnError: false
                        });
                        return temp.innerHTML;
                    }

                    return html;
                },

                // Network Graph Methods

                async switchToNetworkView() {
                    this.currentView = 'network';
                    await this.$nextTick();
                    await this.loadNetworkGraph();
                },

                async loadNetworkGraph() {
                    try {
                        const res = await fetch(`${this.apiBase}/api/graph`);
                        const data = await res.json();
                        this.networkNodes = data.nodes;
                        this.networkEdges = data.edges;
                        this.initNetworkGraph();
                    } catch (e) {
                        console.error('Error loading graph:', e);
                    }
                },

                initNetworkGraph() {
                    const container = document.getElementById('network-graph');
                    if (!container || typeof vis === 'undefined') {
                        console.error('Network graph container or vis.js not found');
                        return;
                    }

                    // Define status-based colors
                    const statusColors = {
                        discovered: '#8B949E',
                        downloaded: '#2D6A4F',
                        summarized: '#5B4B8A',
                    };

                    // Create nodes dataset with colors
                    const nodes = new vis.DataSet(this.networkNodes.map(n => ({
                        id: n.id,
                        label: n.label,
                        title: `${n.title}\n(${n.year || 'n.d.'})`,
                        color: {
                            background: statusColors[n.group] || '#8B949E',
                            border: statusColors[n.group] || '#8B949E',
                            highlight: {
                                background: statusColors[n.group] || '#8B949E',
                                border: '#22324A'
                            }
                        }
                    })));

                    // Create edges dataset
                    const edges = new vis.DataSet(this.networkEdges.map(e => ({
                        from: e.from,
                        to: e.to,
                        title: e.title,
                        smooth: { type: 'continuous' }
                    })));

                    // Network options
                    const options = {
                        nodes: {
                            font: { size: 12, face: 'Inter, sans-serif' },
                            borderWidth: 2,
                            shape: 'dot',
                            size: 15
                        },
                        edges: {
                            width: 1,
                            color: { color: '#D4C9B8', highlight: '#22324A' }
                        },
                        physics: {
                            barnesHut: {
                                gravitationalConstant: -2000,
                                springLength: 150
                            }
                        },
                        interaction: {
                            hover: true,
                            tooltipDelay: 200
                        }
                    };

                    // Create network
                    this.networkGraph = new vis.Network(container, { nodes, edges }, options);

                    // Handle node click -> view paper detail
                    this.networkGraph.on('click', (params) => {
                        if (params.nodes.length > 0) {
                            const citekey = params.nodes[0];
                            this.viewPaperDetail(citekey);
                        }
                    });

                    // Handle double-click -> set as connection source
                    this.networkGraph.on('doubleClick', (params) => {
                        if (params.nodes.length > 0) {
                            this.connectSource = params.nodes[0];
                        }
                    });
                },

                async connectPapers() {
                    if (!this.connectSource || !this.connectTarget) return;

                    try {
                        const res = await fetch(`${this.apiBase}/api/graph/connect`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                source: this.connectSource,
                                target: this.connectTarget,
                                reason: this.connectReason
                            })
                        });
                        const data = await res.json();

                        if (data.status === 'connected') {
                            this.statusMessage = 'Papers connected successfully';
                            this.statusType = 'success';
                            // Reload the graph
                            await this.loadNetworkGraph();
                        } else if (data.status === 'exists') {
                            this.statusMessage = 'Connection already exists';
                            this.statusType = 'info';
                        }

                        // Clear form
                        this.connectSource = '';
                        this.connectTarget = '';
                        this.connectReason = '';
                    } catch (e) {
                        this.statusMessage = `Error: ${e.message}`;
                        this.statusType = 'error';
                    }
                }
            };
        }
    </script>
</body>
</html>
